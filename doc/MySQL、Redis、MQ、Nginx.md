# MySQL、Redis、MQ、Nginx

## MySQL

### jdbc 操作数据库流程

1、加载数据库驱动；2、获取连接；3、创建数据库操作对象；
4、执行SQL语句；5、获取结果集；6、释放资源；

### 事务的基本要素（ACID）

原子性 ： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；
一致性： 执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；
隔离性： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；
持久性： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。

### ANSI SQL隔离级别标准

**Read Uncommitted（未提交读）**： 一个事务能读取到其他事务修改过，但是还没有提交的数据；事务存在着回滚的可能性；存在脏读/不可重复读/幻读；
**Read Committed（已提交读）**： 一个事务能读取到其他事务提交过的数据。存在不可重复读/幻读；
一个事务在处理过程中如果重复读取某一个数据，而且这个数据恰好被其他事务修改并提交了，那么当前重复读取数据的事务就会出现同一个数据前后不同的情况。在这个隔离级别会发生“不可重复读”的场景。
**Repeatable read（可重复读）**mysql默认：一个事务一旦开始，事务过程中所读取的所有数据不允许被其他事务修改；只保证了读取出数据在当前事务中不被修改，但是该数据本体能被其他事务修改。存在幻读：事务A 按照一定条件进行数据读取， 期间事务B 插入了相同搜索条件的新数据，事务A再次按照原先条件进行读取时，发现了事务B 新插入的数据 称为幻读；
mysql出现幻读的场景：
在RR隔离级别下，如果一个事务从头到尾就只有快照读，那么MVCC解决了幻读的问题。如果一个事务从头到尾只有当前读，那么MVCC通过间隙锁和临建锁也解决了幻读问题。但是如果一个事务既有快照读也有当前读，那么MVCC就解决不了幻读问题
**Serializable**（序列化）： 所有的事务以串行地方式逐个执行，所以能避免所有数据不一致；会导致事务排队，系统的并发量大幅下降；

### MVCC版本号机制和Next key lock

### Spring事务的传播级别（七种）

默认propagation_required：如果当前没有事务，就创建一个事务，如果当前存在事务，就加入该事务；

### MyISAM和InnoDB的区别

1、InnoDB支持事务支持外键，MyISAM不支持；
2、InnoDB支持数据行锁定，MyISAM不支持行锁定，只支持锁定整个表。 个人认为，这才是大多数人吐槽MYISAM对原因吧。因为事务功能可以通过代码弥补。但锁表可是性能但罪魁祸首；
3、InnoDB是聚集索引，数据文件是和索引绑在一起的，必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。而MyISAM是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的；
索引
关系数据库中字段的值进行预排序的数据结构。通过使用索引，可以让数据库系统不必扫描整个表，而是直接定位到符合条件的记录，这样就大大加快了查询速度。

### 索引类型

常用的有主键索引、唯一索引、普通索引、组合索引；
PRIMARY KEY主键索引：定义主键将自动创建主键索引，一张数据表有只能有一个主键，不能为null不能重复；
UNIQUE唯一索引：使用唯一索引的数据不能重复，但允许为 NULL，一张表允许创建多个唯一索引；
INDEX普通索引：作用是加快查找速度，并允许数据重复和 NULL；
组合索引：即一个索引包含多个列；为了更多的提高mysql效率可建立组合索引，遵循”最左前缀“原则；
写sql的时候先把组合索引左边字段的条件放在左边，这样才不会索引失效；

### 执行计划（SQL性能分析）

估算扫描多少行数据，有无使用索引；

![image _3_.png](https://s2.loli.net/2023/03/04/my3eGUwDZgjn4zi.png)

执行计划中的列怎么看？
key：实际使用的索引；
rows：估算要读取的行数；越小越好；
filtered：返回结果的行数占读取行数的百分比，值越大越好；

### 索引数据结构

<img src="https://s2.loli.net/2023/03/04/xFzD9imu5lORAT7.png" alt="742091450_1600766893053_D4FB89FD561575C83E7FA09CEA7A9E57.png" style="zoom:50%;" />

二叉查找树（BST）：也叫二叉搜索树，是一种二叉树；
1、所有结点存储一个值；
2、所有非叶子结点至多拥有两个儿子；
3、左子树上所有结点的值小于它根结点的值，右子树上所有结点的值大于它根结点的值；
查找流程：从根结点开始，如果查询的值与结点的值相等，那么就命中；如果查询值比结点值小，就进入左儿子；如果比结点值大，就进入右儿子；如果左儿子或右儿子的指针为空，则找不到相应的值；
比起循环遍历的查找方法，二叉查无需遍历所有元素并比较，所以更快；
缺点：极端情况下会变成一种线性链表似的结构；
平衡二叉树（AVL）：又叫自平衡二叉树，是平衡的二叉搜索树，每一个结点的左子树的高度和右子树的高度差至多为1；由于要维持自身的平衡，所以进行插入和删除结点时，需要对结点进行频繁的旋转，旋转是对整棵树的操作，数据很大时若只有部分加载到内存中则无法完成旋转；
缺点：进行查找时，需要多次磁盘IO；
每次查询是将磁盘中的一页数据加入内存，树的每一层节点存放在一页中，不同层数据存放在不同页，这样如果需要多层查询就需要多次磁盘IO；
空间局部性原理：如果一个存储器的某个位置被访问，那么将它附近的位置也会被访问；
B 树（Blance-Tree）：允许每个节点有更多的子节点（多叉树）；

<img src="https://s2.loli.net/2023/03/04/UPvYBRkKXIi1asg.webp" alt="1446087-b6d4754304fa8955.webp" style="zoom:50%;" />
相对于平衡二叉树的优点：每次IO查找读取的数据更多，树的高度低，所以IO次数少；
B+树（）：只在叶子节点存储数据；为所有叶子结点增加了一个链指针；

<img src="https://s2.loli.net/2023/03/04/zMdqB14DbgHCWsT.webp" alt="1446087-30b70aaa28403803.webp" style="zoom:50%;" />
相对于B树的优点：
1、非叶子节点都只是索引值，没有实际的数据，在一次IO里面，能读出的索引值更多；
2、根据局部性原理，树叶节点两两相连可增加区间访问性，使用范围查询时速度更快；
磁盘是分区块的，一次磁盘IO会读取若干个区块，由于区块大小是固定的，区块中单个元素越小，存的数据数量就越多；所以在一次IO中，B+树读取到更多的索引；

### 数据库规范

表设计规范
1、字段允许适当冗余，以提高查询性能；（不是频繁修改的字段）
2、字段尽量设置为NOT NULL，为字段提供默认值；
3、必须有id、插入时间、修改时间这3个字段；
4、任何字段如果为非负数，必须是unsigned无符号的；
5、小数类型为decimal，禁止使用float和double；
索引设计规范
1、更新频繁的字段不用建索引；
2、区分度不高的字段不用建索引；（如性别）
索引失效场景
1、模糊查询的时候把通配符放在最左边；使用不等号查询；使用is not null；使用not in；
2、查询的索引字段使用了函数运算、类型转换（显示或隐式）；
3、使用或者条件查询时前后存在非索引的列；
4、复合索引未用左列字段；
走了索引还是慢怎么办？
避免回表，调大缓冲池innodb_buffer_pool_size，为机器物理内存的1/4；
回表：主键索引的叶子结点存储的是一行完整的数据，非主键索引的叶子结点存储的则是主键值；
如果是通过主键索引来查询数据，只需要搜索主键索引的B+Tree就可以找到数据；
如果是通过非主键索引来查询数据，需要先搜索非主键列索引的B+Tree，搜索完成后得到主键的值，然后再去搜索主键索引的B+Tree，就可以获取到一行完整的数据，这个过程就是所谓的回表；
小表驱动大表；多表关联查询，将小表放在前面，先扫小表，扫描快效率较高，在扫描后面的大表；
hint优化；

### Binlog日志的三种模式

1 Statement Level模式
2 Row Level模式
3 Mixed模式（混合模式）

## Redis

### 为什么快？

1、基于内存操作，内存读写速度快；
2、Redis是单线程的，避免线程切换开销及多线程的竞争问题；

### 数据类型（常见5种）

string（字符串）：一个 key 对应一个 value；二进制安全；
存java对象时先序列化，比hash节省内存空间；
hash（哈希）：value是键值对集合，类似Java的hashmap，适合存储对象；
list（列表）：有序可重复的集合，按照插入顺序排序，底层是双向链表，所以可以实现栈和队列；
set（集合）：无序去重的集合，提供了多个 set 之间的聚合运算，如求交集、并集、补集；
sorted set（有序集合）：不重复，每个元素都会关联一个 double 类型的分数，通过这个分数给集合中的成员进行从小到大的排序；
特殊：Bitmap、Hyperloglog、Geospatial 

### 持久化方式

rdb（默认）：快照文件；把当前内存中的数据生成快照写入硬盘；
aof：命令追加；将执行的命令行逐句记录下来；默认策略appendf sync everysec每秒钟同步一次（最多丢失1秒数据）；
生产上用哪个：1、只用aof，数据更完整；2、aof文件可阅读，误操作时可以直接修改aof文件后恢复数据；
3、备份的aof文件可修复，机器突然断电时，aof文件末尾命令不完整无法启动，删除不完整的命令即可启动；
而rdb快照文件损坏无法修复；
aof文件过大问题：当AOF文件的大小超过了配置的阈值时，Redis就会启动AOF文件压缩，只保留可以恢复数据的最小指令集；默认配置-当AOF文件大小是上次大小的一倍且文件大于64M时触发；

### 过期策略

过期策略和内存淘汰策略是两个完全不同的概念。
过期策略指的是Redis使用哪种策略，来删除已经过期的键值对。
内存淘汰策略是，当Redis运行内存已经超过Redis设置的最大内存，将采用什么策略来删除符合条件的键值对
1、定时删除；当key设置有过期时间，且过期时间到达时，由定时器任务执行对key的删除操作。
优点：节约内存，到时就删除，快速释放掉不必要的内存占用
缺点：CPU压力很大，无论CPU此时负载量多高，均占用CPU，会影响redis服务器响应时间和指令吞吐量
2、惰性删除；只有当key被访问时，才会判断该key是否已过期，过期则清除。可以最大化地节省CPU资源，却对内存非常不友好。极端情况可能出现大量的过期key没有再次被访问，从而不会被清除，占用大量内存；
3、定期删除；每隔一定的时间，会随机抽取一定数量的key，并清除其中已过期的key；
Redis同时使用了惰性过期和定期过期两种过期策略。但是Redis定期删除是随机抽取机制，不可能扫描删除掉所有的过期Key。因此需要内存淘汰机制。

### 内存淘汰策略-8种

no-eviction：当内存不足以容纳新写入数据时，新写入操作会报错。
allkeys-lru（常用）：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。
allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key。
volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key。
volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key。
volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除。
redis4.0后 volatile-lfu：淘汰所有设置了过期时间的键值中，最少使用的键值。
redis4.0后 allkeys-lfu（常用）：淘汰整个键值中最少使用的键值。
LRU算法缺点
LRU算法有一个缺点，比如说很久没有使用的一个键值，如果最近被访问了一次，那么它就不会被淘汰，即使它是使用次数最少的缓存，那它也不会被淘汰。
LFU 算法
LFU 全称是Least Frequently Used翻译为最不常用的，最不常用的算法是根据总访问次数来淘汰数据的，它的核心思想是如果数据过去被访问多次，那么将来被访问的频率也更高。
LFU解决了偶尔被访问一次之后，数据就不会被淘汰的问题，相比于LRU算法也更合理一些

### 如何保证Redis中的数据都是热点数据？

1、计算一下热点数据大约占用的内存，然后在配置文件设置Redis最大占用内存限制；
2、并将内存淘汰策略设置为allkeys-lru；当内存不足时移除最近最少使用的key；

### 大key问题

所谓的大key问题是某个key的value比较大，所以本质上是大value问题；Redis是单线程，单个耗时过大命令，导致阻塞其他命令；
大key有多大：value是String类型时，size超过10KB；value是ZSET、Hash、List、Set等集合类型时，它的成员数量超过1w个；不同公司定义不同
大key是如何产生的：往往是业务方设计不合理，没有预见vaule的动态增长，没有删除机制；
查找大key：使用bigkeys命令；
如何解决：设置过期时间；数据拆分；
删除大key：异步删除命令unlink；

### 缓存击穿（失效）

高并发流量访问热点数据时，热点数据的缓存失效，直接请求数据库；
解决办法
1、考虑设置永远不过期；
2、互斥锁限制数据库请求：在缓存数据为空的时候，设置一个互斥的锁，只让一个请求通过，只有一个请求去数据库拉取数据，取完数据，不管如何都需要释放锁；其他的请求，如果没有获取到锁，应该等待，再重试；

### 缓存穿透（缓存成了摆设）

缓存和数据库都没有的数据，被大量请求，导致这个不存在的数据每次请求都要到数据库去查询；
解决办法
1、缓存空对象：如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过2分钟；
2、布隆过滤器：在数据写入数据库的同时将这个 ID 同步到到布隆过滤器中，当请求的 id 不存在布隆过滤器中则说明该请求查询的数据一定没有在数据库中保存，就不要去数据库查询了；

### 缓存雪崩

缓存同一时间大面积的失效，从而导致所有请求都去查数据库；
解决办法
1、过期时间添加随机值，避免大量缓存在同一时间失效；
2、如果是redis故障导致的缓存雪崩，服务熔断和限流；服务熔断就是当从缓存获取数据发现异常，则直接返回错误数据给前端，防止所有流量打到数据库导致宕机。服务熔断和限流属于在发生了缓存雪崩，如何降低雪崩对数据库造成的影响的方案；

### 如何保证缓存和数据库数据的一致性？

原因：当数据发生更新时，我们不仅要操作数据库，还要一并操作缓存；
1、先删除缓存，后更新数据库；
2、先更新数据库，后删除缓存；
这两种方案，只要第二步发生失败，那么就会导致数据库和缓存不一致；
保证第二步成功执行，就是解决问题的关键

<img src="https://s2.loli.net/2023/03/04/lGY56WOhJx8HNkV.png" alt="Snipaste_2023-02-25_21-36-57.png" style="zoom:33%;" />
**订阅数据库变更日志投递到MQ，再操作缓存（BinLog缓存删除方案）**
具体来讲就是，我们的业务代码在修改数据时，只需修改数据库数据，无需操作缓存；
当一条数据发生修改时，MySQL就会产生一条变更日志（Binlog），我们可以用阿里的canal订阅这个日志，拿到具体操作的数据，然后再根据这条数据，去删除对应的缓存。
为什么是删除缓存而不是更新：并发时先更新数据库的线程，后更新缓存，会出现数据不一致的情况；而删除缓存不会，只会出现缓存失效；
为什么要用MQ：具有持久化、失败重试功能；
相对于不用canal的优点：
1、不用在业务代码里操作MQ；业务代码不再关心缓存更新操作
2、无需考虑写消息队列失败情况，只要写 MySQL 成功，Binlog 肯定会有；
阿里巴巴binlog增量订阅&消费组件
为什么不用缓存双删？
延迟删除的时间不好定义

### Redis事务

Redis 具备了一定的原子性，但不支持回滚；
Redis 不具备 ACID 中一致性的概念；
Redis 具备隔离性；
Redis 无法保证持久性；

### 部署方式-集群方案

1、主从复制模式：包含一个主数据库实例（master）与一个或多个从数据库实例（slave），可对主数据库进行读写操作，对从数据库进行读操作，主数据库写入的数据会实时自动同步给从数据库；
缺点：不具备自动容错与恢复功能，难以支持在线扩容，Redis的容量受限于单机配置；
2、Sentinel（哨兵）模式：基于主从复制模式，引入了哨兵来监控与自动处理故障；当master出现故障时，能自动将一个slave转换为master；
难以支持在线扩容，Redis的容量受限于单机配置
3、Cluster模式：缓存数据分散在多个节点上，来解决在线扩容的问题；
无中心化架构，实现分布式存储，可进行线性扩展，也能高可用

## MQ

### 作用

异步处理：非核心流程异步化，提高了应用程序的响应时间；
异步场景：用户投保承保后，数据写库后需要发短信和邮件通知已承保。数据写库后前端立即返回已承保的界面，短信和邮件消息发到消息队列等待消费；因前端已显示承保，短信和邮件可以不用立即发送；
应用解耦：降低应用之间的耦合
解耦场景：监管要求，60岁以上的人买保险需要录音录像证明是自愿购买；前端录像后调用投保系统，投保系统调用核保系统；
如果核保系统挂了，投保系统这个接口就不可用，等核保恢复后还要在前端再调用一次；
用MQ后，投保系统把消息发到MQ后，前端就显示正在审核，如果核保系统挂了，等核保恢复后自己去消费消息，不影响其他系统；
流量削峰：
流量削锋也是消息队列中的常用场景，一般在秒杀或团抢活动中使用广泛！
应用场景：秒杀活动，一般会因为流量过大，导致流量暴增，应用挂掉。为解决这个问题，一般需要在应用前端加入消息队列。
可以控制活动的人数，可以缓解短时间内高流量压垮应用。
用户的请求，服务器接收后，首先写入消息队列。假如消息队列长度超过最大数量，则直接抛弃用户请求或跳转到错误页面。
秒杀业务根据消息队列中的请求信息，再做后续处理。

### 怎么确保消息投递可靠性（保证消息不丢失）

生产端：开启消息投递确认机制，生产者投递消息后，如果队列容器收到消息，则会给我们生产这一个应答；
如果队列容器返回写入失败等错误消息，需要重试发送。当多次发送失败需要发告警邮件；
队列容器：开启持久化
消费端：开启手动确认签收机制，如果设置了手动确认方式，则需要在消费者真正执行完业务逻辑之后，调用方法手动签收，队列容器才会把消息删除；（不要拿到消息后马上签收）

### 消息幂等性（重复发送、重复消费问题）

多次执行对资源本身所产生的影响均与一次执行的影响相同。在MQ中指，消费多条相同的消息，得到与消费该消息一次相同的结果。消息重复发送问题无法避免，因为无法完全保证网络连接。
1、生产者已把消息发送到mq，在mq给生产者返回ack的时候网络中断，故生产者未收到确定信息，生产者认为消息未发送成功，但实际情况是，mq已成功接收到了消息，在网络重连后，生产者会重新发送刚才的消息，造成mq接收了重复的消息。
（1）消息id，记录并检查操作（不适用于分布式系统）
生产者在发送消息时，给消息对象设置了唯一ID；
消费端代码，先去redis判断是否存在该ID了，如果存在表明已经消费过了则直接返回，不再消费；
如果id不存在，消费端消费并确认签收后把该ID存至redis中；
（2）幂等消费
需要修改消费端业务代码
（3）MVCC
更通用的，是给数据增加版本号version属性，每次更新数据前，比较
当前数据version == 消息中的version
不一致，拒绝更新
一致，更新数据同时将版本号+1，一样则可实现幂等更新

### 保证消息有序

把需要保证有序的消息一个queue，对应单个消费者，单线程消费即可；
除非业务一定要保持顺序，否则无需处理顺序性问题，毕竟处理顺序性时会导致性能下降；

### 消息堆积

1、队列上绑定多个消费者多线程，提高消费速度；
2、使用惰性队列，可以再mq中保存更多消息；

## RabbitMQ

<img src="https://s2.loli.net/2023/03/04/Yyp9AxoRTbEfnZW.png" alt="Snipaste_2023-02-25_14-01-33.png" style="zoom:50%;" />
Exchange：消息队列交换机。按一定的规则将消息路由转发到某个队列。
Queue：消息队列，存储消息的队列。

### 交换机类型

1、direct完全匹配：只将消息发送到完全匹配到此路由键的队列；
注意同一个key，可以绑定多个队列，这样多个队列都会有相同的消息数据；
2、fanout广播：会将消息分发给所有绑定了此交换机的队列，此时路由键参数无效；
简单快速，性能最好，因为少了中间的匹配判断环节；
3、topic通配符：可以进行模糊匹配，Direct是完全匹配；
4、headers：不通过路由键来分发消息，而是通过消息内容中的headers属性来进行匹配；
性能差，在实际中并不常用；
性能排序：fanout > direct >> topic。比例大约为11：10：6
BindingKey(绑定键)：建立Exchange与Queue之间的关系（个人看作是一种规则，也就是Exchange将什么样的消息路由到Queue）
RoutingKey(路由键)：Producer发送消息与路由键给Exchange，Exchange将判断RoutingKey是否符合BindingKey，如何则将该消息路由到绑定的Queue；

### 消息模型

1、简单模式 HelloWorld
一个生产者、一个消费者，不需要设置交换机（使用默认的交换机）
2、工作队列模式 Work Queue
一个生产者、多个消费者（竞争关系），不需要设置交换机（使用默认的交换机）
3、发布订阅模式 Publish/subscribe
需要设置类型为fanout的交换机，并且交换机和队列进行绑定，当发送消息到交换机后，交换机会将消息发送到绑定的队列
4、路由模式 Routing
需要设置类型为direct的交换机，交换机和队列进行绑定，并且指定routing key，当发送消息到交换机后，交换机会根据routing key将消息发送到对应的队列
5、通配符模式 Topic
需要设置类型为topic的交换机，交换机和队列进行绑定，并且指定通配符方式的routing key，当发送消息到交换机后，交换机会根据routing key将消息发送到对应的队列

## Nginx

### 正向代理和反向代理

正向代理服务器，隐藏的是客户端
反向代理服务器，隐藏的是服务器

### 负载均衡策略（7种）

轮询（默认）：每个请求按时间顺序逐一分配到不同的后端服务器；
weight 权重：设置权重，权重越高，在被访问的概率越大；
ip_hash：每个访客固定访问一个后端服务器，可以解决session的问题；
最少连接：web请求会被转发到连接数最少的服务器上；
随机：
公平fair（第三方）：根据后端服务器的响应时间 来分配请求，响应时间短的优先分配；
url_hash（第三方）：按访问的URL的哈希结果来分配请求；

## JVM

JVM的内存结构（5个区域）：虚拟机栈、本地方法栈、程序计数器、堆、方法区；
虚拟机栈（线程私有）：存放局部变量表、操作数栈、动态链接、方法出口信息；
本地方法栈（C 栈）（线程私有）：是为JVM运行Native方法准备的空间；
程序计数器（线程私有）：用于指令切换，分支、跳转、循环、异常处理、线程恢复等等基础操作都会依赖这个计数器来完成；
堆（线程共享）：存放对象，占用内存空间最大，垃圾回收的主要区域；分为新生代和老年代
方法区（线程共享）：存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据，
方法区的内存回收目标主要是针对常量池的回收和对类型的卸载；
永久代（方法区的实现方式）：方法区中的信息一般需要长期存在，而且它又是堆的逻辑分区，因此用堆的划分方法，把方法区的实现称为永久代；
元空间：java8开始，元空间取代永久代，永久代物理是是堆的一部分，和新生代，老年代地址是连续的，而元空间属于本地内存；元空间存储类的元信息，而静态变量和常量池等并入堆中，相当于永久代的数据被分到了堆和元空间中。
运行时常量池：一直在方法区；
字符串常量池：java8开始，在堆中；